Architecture 

It is a domain driven architecture even though the business layout doesn't have that much login, I design that way thinking about how this kind of application could evolve over time. So, a business layer will be useful to isolated business logic and reduce complexity of the view models since they already have a lot of UI logic to taking care of.  

The structure of the app applies reactive principles in some parts supported by flow and coroutines. They mostly run on the main thread, even asynchronous calls, given that unlike threads the suspending blocks don't affect the main thread performace that much if they are short task and tha was the case, so not any other dispatchers were used, and the scope always was ViewModelsScope to guarantee cancelation according to the lifecycle. The exceptions and other controlled errors are passed from the data layer to the UI and each layer has the responsibility to map those error according to certain rules and decide if it needs to be showed to the user or just log internally. I didn’t implement the error management for all the cases and all the layers but the implemented squeme shows how it could be managed and scaled by adding the corresponding mapper on each layer.  

The post details fragment where the user can see a post detail has two sections. The user and post information are on the first section, and they are downloaded completely independent of the comments (which have to be downlead using another end-point) section. This a more reactive approach where the user can see the information as soon and it is available, and each section reacts to the stream of items showing immediately its update state,  

The application has four layers and applies certain Clean Architecture principles. But, having into account the limited time frame, the extend, and the size of this test, it has some simplifications. It applies the dependency inversion patter to isolate the repository from the business layer, but I decided to reuse some of the entities as immutable objects for the business layer to avoid a lot of mappers and boiler plate that may be necessary in a real time apps to guarantee isolation. If the app were to scale, it will be convenient to isolate the layers completely, but having into account constraints (business requirement, time, resources, etc) 

Data 

It uses a repository, but it isn't using the repository pattern, (it doesn't have a Datasource abstraction) it is just a singleton object with the responsibility of bring the data asked by the related usecase in the business layers from the api, the database and the shared preferences. It abstracts the remote and local data management. It uses flow to emit asynchronously and update the database with the data downloaded from the API. It uses Room and Kotlin Flow to emit items when the database is updated because this design uses the database as the source of truth and each change is shown to the user immediately. If the app were bigger and some random changes were made in other sections of the view to a post using for example some asynchronous request (eg a request to the server) all the corresponding changes will be shown as soon as the server answer arrive. This reactive approach is useful for showing the source of truth state as soon as possible and for isolating side effect since they are all manage as an emitted event by the flow coming from the database, but it has to be used with caution in real life apps because it can generate problems if the ui state is not properly controlled, considering that we can be sure when an event will be emitted. 


Domain business rules 

This will be (at least in theory because it depends on the app) the layer less modified over time, so it is convenient to have it completely isolated without any dependence to other layer. It contains all the business logic. On real life apps I’ve found this layer very useful to avoid mixing UI login with business logic causing big and complex view models. In this case, it was not necessary (all of them are just thin function calling a repo function and some mappers were omitted) but I use this approach assuming the app will grow over time. 


Viewmodels 

I use MVVM using Coroutines, Flow and Livedata to deliver the state to the UI. The Viewmodels manage the views state, but unlike other designs (MVC, MVP) they are agnostic of them since they don't have any references to them and that's very helpful for testability (I added a few unit tests to the getPost function where using dependency injection ad a complement made easy to generate input and read the outputs without requiring any UI Android framework component nor complex configuration or logic). It uses the observer pattern taking advantage of the Livedata class properties. It is lifecycle aware and was built to work in conjunction with Viewmodels to survive different lifecycle changes to the activities and fragments involved. There are other approaches using Flow, but I have found the lifecycle management is most simple and easy to use. 

 

Views 

I use an “activity with several fragment” structure using the jetpack Navigation library. It simplifies the fragment stack management and the use of shared data, as well as other useful features like navigation bar integration. I wanted to use pagination at first but the API just return 100 items and it doesn't provide enough features. Using MVVM and the Viewmodel as state containers, the fragments are very symple the just render the state objects. The details Fragment gets data from two different reactive streams of data, so it manages the post-user section and the comment section independently given that the data corresponding to the details is stored on demand and not all ta once and it needs different endpoints to get the information. The post list fragment (star point of the app) obtains his data main from the reactive stream coming from the updates to the source of truth, which is sqlite table corresponding to the Post entity. 
